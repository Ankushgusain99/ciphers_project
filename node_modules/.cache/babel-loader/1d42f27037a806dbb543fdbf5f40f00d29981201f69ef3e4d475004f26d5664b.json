{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\ankus\\\\OneDrive\\\\Desktop\\\\Pro\\\\ciphers\\\\src\\\\components\\\\ciphers\\\\ADFGVX.js\",\n  _s = $RefreshSig$();\nimport React from 'react';\nimport CipherFactory from '../../ui/EncryptDecrypt';\nimport { jsxDEV as _jsxDEV, Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nexport default function ADFGVC({\n  ongetInfo\n}) {\n  _s();\n  const adfgvx = 'ADFGVX';\n  let polybiusSquare = createPolybiusSquare('phqgiumeaylnofdxkrcvstzwb');\n  function createPolybiusSquare(alphabet) {\n    const size = 6;\n    let square = [];\n    for (let i = 0; i < size; i++) {\n      square[i] = [];\n      for (let j = 0; j < size; j++) {\n        square[i][j] = alphabet[i * size + j];\n      }\n    }\n    return square;\n  }\n  function indexOf2d(arr, val) {\n    for (let i = 0; i < arr.length; i++) {\n      let index = arr[i].indexOf(val);\n      if (index > -1) {\n        return [i, index];\n      }\n    }\n    return [-1, -1];\n  }\n  function encode(plaintext, key) {\n    plaintext = plaintext.toLowerCase().replace(/[^a-z]/g, '');\n    let cipher = '';\n\n    // Substitute with Polybius Square\n    for (let char of plaintext) {\n      let [row, col] = indexOf2d(polybiusSquare, char);\n      cipher += adfgvx[row] + adfgvx[col];\n    }\n\n    // Columnar Transposition\n    return transpositionCipher(cipher, key);\n  }\n  function decode(ciphertext, key) {\n    let decrypted = reverseTranspositionCipher(ciphertext, key);\n    let plaintext = '';\n\n    // Reverse Polybius Square substitution\n    for (let i = 0; i < decrypted.length; i += 2) {\n      let row = adfgvx.indexOf(decrypted[i]);\n      let col = adfgvx.indexOf(decrypted[i + 1]);\n      plaintext += polybiusSquare[row][col];\n    }\n    return plaintext;\n  }\n  function transpositionCipher(text, key) {\n    // Create an array to represent key-index mapping\n    let keyMap = [];\n    for (let i = 0; i < key.length; i++) {\n      keyMap.push({\n        char: key[i],\n        index: i\n      });\n    }\n\n    // Sort the key map based on alphabetical order of key\n    keyMap.sort((a, b) => a.char.localeCompare(b.char));\n\n    // Create the matrix to cipher the text\n    let rowLength = key.length;\n    let textLength = text.length;\n    let numRows = Math.ceil(textLength / rowLength);\n    let matrix = [];\n    for (let i = 0; i < numRows; i++) {\n      let row = text.slice(i * rowLength, (i + 1) * rowLength).padEnd(rowLength, ' ');\n      matrix.push(row.split(''));\n    }\n\n    // Transpose the matrix based on the key map\n    let cipherText = '';\n    for (let {\n      index\n    } of keyMap) {\n      for (let row of matrix) {\n        cipherText += row[index];\n      }\n    }\n    return cipherText.replace(/ /g, ''); // Remove padding spaces\n  }\n  function reverseTranspositionCipher(text, key) {\n    // Reverse the process of the transpositionCipher function\n    let keyMap = [];\n    for (let i = 0; i < key.length; i++) {\n      keyMap.push({\n        char: key[i],\n        index: i\n      });\n    }\n    keyMap.sort((a, b) => a.char.localeCompare(b.char));\n    let colLength = Math.ceil(text.length / key.length);\n    let numRows = key.length;\n    let totalCells = colLength * numRows;\n    let padding = totalCells - text.length;\n    let matrix = [];\n    for (let i = 0; i < numRows; i++) {\n      matrix.push(new Array(colLength).fill(' '));\n    }\n    let index = 0;\n    for (let {\n      index: keyIndex\n    } of keyMap) {\n      for (let i = 0; i < colLength; i++) {\n        if (padding > 0 && i === colLength - 1 && keyIndex >= numRows - padding) {\n          continue;\n        }\n        matrix[keyIndex][i] = text[index];\n        index++;\n      }\n    }\n\n    // Read the matrix row-wise to get the original text\n    let originalText = '';\n    for (let i = 0; i < colLength; i++) {\n      for (let j = 0; j < numRows; j++) {\n        originalText += matrix[j][i];\n      }\n    }\n    return originalText.replace(/ /g, ''); // Remove padding spaces\n  }\n  const showInformation = () => {\n    const info = /*#__PURE__*/_jsxDEV(_Fragment, {\n      children: [/*#__PURE__*/_jsxDEV(\"p\", {\n        children: \"The ADFGVX cipher is a field cipher used by the German Army during World War I.\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 136,\n        columnNumber: 17\n      }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n        children: \"To encrypt using the ADFGVX cipher, a Polybius square and a transposition cipher are combined.\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 139,\n        columnNumber: 17\n      }, this), /*#__PURE__*/_jsxDEV(\"ul\", {\n        children: [/*#__PURE__*/_jsxDEV(\"li\", {\n          children: \"Substitution Cipher: The plaintext is first converted into pairs of ADFGVX characters based on their positions in a Polybius square.\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 143,\n          columnNumber: 21\n        }, this), /*#__PURE__*/_jsxDEV(\"li\", {\n          children: \"Transposition: The resulting pairs are then reordered according to a keyword.\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 144,\n          columnNumber: 21\n        }, this), /*#__PURE__*/_jsxDEV(\"li\", {\n          children: \"Encryption: The final result is the encrypted ciphertext.\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 145,\n          columnNumber: 21\n        }, this), /*#__PURE__*/_jsxDEV(\"li\", {\n          children: \"Decryption: The ciphertext is reordered according to the keyword to retrieve the pairs of ADFGVX characters, which are then converted back into plaintext.\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 146,\n          columnNumber: 21\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 142,\n        columnNumber: 17\n      }, this)]\n    }, void 0, true);\n    ongetInfo(info);\n  };\n  React.useEffect(() => {\n    showInformation();\n  }, []);\n  return /*#__PURE__*/_jsxDEV(_Fragment, {\n    children: /*#__PURE__*/_jsxDEV(CipherFactory, {\n      encode: encode,\n      decode: decode,\n      keyComponentA: 'abc'\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 159,\n      columnNumber: 13\n    }, this)\n  }, void 0, false);\n}\n_s(ADFGVC, \"OD7bBpZva5O2jO+Puf00hKivP7c=\");\n_c = ADFGVC;\n;\nvar _c;\n$RefreshReg$(_c, \"ADFGVC\");","map":{"version":3,"names":["React","CipherFactory","jsxDEV","_jsxDEV","Fragment","_Fragment","ADFGVC","ongetInfo","_s","adfgvx","polybiusSquare","createPolybiusSquare","alphabet","size","square","i","j","indexOf2d","arr","val","length","index","indexOf","encode","plaintext","key","toLowerCase","replace","cipher","char","row","col","transpositionCipher","decode","ciphertext","decrypted","reverseTranspositionCipher","text","keyMap","push","sort","a","b","localeCompare","rowLength","textLength","numRows","Math","ceil","matrix","slice","padEnd","split","cipherText","colLength","totalCells","padding","Array","fill","keyIndex","originalText","showInformation","info","children","fileName","_jsxFileName","lineNumber","columnNumber","useEffect","keyComponentA","_c","$RefreshReg$"],"sources":["C:/Users/ankus/OneDrive/Desktop/Pro/ciphers/src/components/ciphers/ADFGVX.js"],"sourcesContent":["import React from 'react';\r\nimport CipherFactory from '../../ui/EncryptDecrypt';\r\n\r\nexport default function ADFGVC({ ongetInfo }) {\r\n\r\n    const adfgvx = 'ADFGVX';\r\nlet polybiusSquare = createPolybiusSquare('phqgiumeaylnofdxkrcvstzwb');\r\n\r\nfunction createPolybiusSquare(alphabet) {\r\n  const size = 6;\r\n  let square = [];\r\n  for (let i = 0; i < size; i++) {\r\n    square[i] = [];\r\n    for (let j = 0; j < size; j++) {\r\n      square[i][j] = alphabet[i * size + j];\r\n    }\r\n  }\r\n  return square;\r\n}\r\n\r\nfunction indexOf2d(arr, val) {\r\n  for (let i = 0; i < arr.length; i++) {\r\n    let index = arr[i].indexOf(val);\r\n    if (index > -1) {\r\n      return [i, index];\r\n    }\r\n  }\r\n  return [-1, -1];\r\n}\r\n\r\nfunction encode(plaintext, key) {\r\n  plaintext = plaintext.toLowerCase().replace(/[^a-z]/g, '');\r\n  let cipher = '';\r\n\r\n  // Substitute with Polybius Square\r\n  for (let char of plaintext) {\r\n    let [row, col] = indexOf2d(polybiusSquare, char);\r\n    cipher += adfgvx[row] + adfgvx[col];\r\n  }\r\n\r\n  // Columnar Transposition\r\n  return transpositionCipher(cipher, key);\r\n}\r\n\r\nfunction decode(ciphertext, key) {\r\n  let decrypted = reverseTranspositionCipher(ciphertext, key);\r\n  let plaintext = '';\r\n\r\n  // Reverse Polybius Square substitution\r\n  for (let i = 0; i < decrypted.length; i += 2) {\r\n    let row = adfgvx.indexOf(decrypted[i]);\r\n    let col = adfgvx.indexOf(decrypted[i + 1]);\r\n    plaintext += polybiusSquare[row][col];\r\n  }\r\n\r\n  return plaintext;\r\n}\r\n\r\nfunction transpositionCipher(text, key) {\r\n  // Create an array to represent key-index mapping\r\n  let keyMap = [];\r\n  for (let i = 0; i < key.length; i++) {\r\n    keyMap.push({ char: key[i], index: i });\r\n  }\r\n\r\n  // Sort the key map based on alphabetical order of key\r\n  keyMap.sort((a, b) => a.char.localeCompare(b.char));\r\n\r\n  // Create the matrix to cipher the text\r\n  let rowLength = key.length;\r\n  let textLength = text.length;\r\n  let numRows = Math.ceil(textLength / rowLength);\r\n  let matrix = [];\r\n\r\n  for (let i = 0; i < numRows; i++) {\r\n    let row = text.slice(i * rowLength, (i + 1) * rowLength).padEnd(rowLength, ' ');\r\n    matrix.push(row.split(''));\r\n  }\r\n\r\n  // Transpose the matrix based on the key map\r\n  let cipherText = '';\r\n  for (let { index } of keyMap) {\r\n    for (let row of matrix) {\r\n      cipherText += row[index];\r\n    }\r\n  }\r\n\r\n  return cipherText.replace(/ /g, ''); // Remove padding spaces\r\n}\r\n\r\nfunction reverseTranspositionCipher(text, key) {\r\n  // Reverse the process of the transpositionCipher function\r\n  let keyMap = [];\r\n  for (let i = 0; i < key.length; i++) {\r\n    keyMap.push({ char: key[i], index: i });\r\n  }\r\n\r\n  keyMap.sort((a, b) => a.char.localeCompare(b.char));\r\n\r\n  let colLength = Math.ceil(text.length / key.length);\r\n  let numRows = key.length;\r\n  let totalCells = colLength * numRows;\r\n  let padding = totalCells - text.length;\r\n  let matrix = [];\r\n\r\n  for (let i = 0; i < numRows; i++) {\r\n    matrix.push(new Array(colLength).fill(' '));\r\n  }\r\n\r\n  let index = 0;\r\n  for (let { index: keyIndex } of keyMap) {\r\n    for (let i = 0; i < colLength; i++) {\r\n      if (padding > 0 && i === colLength - 1 && keyIndex >= numRows - padding) {\r\n        continue;\r\n      }\r\n      matrix[keyIndex][i] = text[index];\r\n      index++;\r\n    }\r\n  }\r\n\r\n  // Read the matrix row-wise to get the original text\r\n  let originalText = '';\r\n  for (let i = 0; i < colLength; i++) {\r\n    for (let j = 0; j < numRows; j++) {\r\n      originalText += matrix[j][i];\r\n    }\r\n  }\r\n\r\n  return originalText.replace(/ /g, ''); // Remove padding spaces\r\n}\r\n\r\n\r\n    const showInformation = () => {\r\n        const info = (\r\n            <>\r\n                <p>\r\n                    The ADFGVX cipher is a field cipher used by the German Army during World War I.\r\n                </p>\r\n                <p>\r\n                    To encrypt using the ADFGVX cipher, a Polybius square and a transposition cipher are combined.\r\n                </p>\r\n                <ul>\r\n                    <li>Substitution Cipher: The plaintext is first converted into pairs of ADFGVX characters based on their positions in a Polybius square.</li>\r\n                    <li>Transposition: The resulting pairs are then reordered according to a keyword.</li>\r\n                    <li>Encryption: The final result is the encrypted ciphertext.</li>\r\n                    <li>Decryption: The ciphertext is reordered according to the keyword to retrieve the pairs of ADFGVX characters, which are then converted back into plaintext.</li>\r\n                </ul>\r\n            </>\r\n        );\r\n        ongetInfo(info);\r\n    };\r\n\r\n    React.useEffect(() => {\r\n        showInformation();\r\n    }, []);\r\n\r\n    return (\r\n        <>\r\n            <CipherFactory encode={encode} decode={decode} keyComponentA={'abc'} />\r\n        </>\r\n    );\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}