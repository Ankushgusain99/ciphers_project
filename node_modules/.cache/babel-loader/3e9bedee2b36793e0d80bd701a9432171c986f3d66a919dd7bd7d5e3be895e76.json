{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\ankus\\\\OneDrive\\\\Desktop\\\\Pro\\\\ciphers\\\\src\\\\components\\\\ciphers\\\\ADFGVX.js\",\n  _s = $RefreshSig$();\nimport React from 'react';\nimport CipherFactory from '../../ui/EncryptDecrypt';\nimport { jsxDEV as _jsxDEV, Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nexport default function ADFGVX({\n  ongetInfo\n}) {\n  _s();\n  const polybiusSquare = [['A', 'D', 'F', 'G', 'V', 'X'], ['A', 'B', 'C', 'D', 'E', 'F'], ['G', 'H', 'I', 'J', 'K', 'L'], ['M', 'N', 'O', 'P', 'Q', 'R'], ['S', 'T', 'U', 'V', 'W', 'X'], ['Y', 'Z', '0', '1', '2', '3'], ['4', '5', '6', '7', '8', '9']];\n  function createPolybiusSquare(keyword) {\n    let alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";\n    keyword = keyword.toUpperCase().replace(/[^A-Z0-9]/g, '');\n    let square = [];\n    let usedChars = new Set();\n    for (let char of keyword) {\n      if (!usedChars.has(char)) {\n        square.push(char);\n        usedChars.add(char);\n      }\n    }\n    for (let char of alphabet) {\n      if (!usedChars.has(char)) {\n        square.push(char);\n        usedChars.add(char);\n      }\n    }\n    let matrix = [];\n    for (let i = 0; i < 6; i++) {\n      matrix.push(square.slice(i * 6, i * 6 + 6));\n    }\n    return matrix;\n  }\n  function getCoordinates(char, square) {\n    for (let i = 0; i < 6; i++) {\n      for (let j = 0; j < 6; j++) {\n        if (square[i][j] === char) {\n          return [polybiusSquare[0][i], polybiusSquare[0][j]];\n        }\n      }\n    }\n    return null;\n  }\n  function encode(plaintext, keyword, transpositionKey) {\n    let square = createPolybiusSquare(keyword);\n    plaintext = plaintext.toUpperCase().replace(/[^A-Z0-9]/g, '');\n    let coordinates = [];\n    for (let char of plaintext) {\n      coordinates.push(...getCoordinates(char, square));\n    }\n    let transposedText = \"\";\n    let transpositionKeyLength = transpositionKey.length;\n    let numRows = Math.ceil(coordinates.length / transpositionKeyLength);\n    let grid = Array.from({\n      length: numRows\n    }, () => new Array(transpositionKeyLength).fill(''));\n    for (let i = 0; i < coordinates.length; i++) {\n      grid[Math.floor(i / transpositionKeyLength)][i % transpositionKeyLength] = coordinates[i];\n    }\n    let sortedKey = transpositionKey.split('').map((char, index) => ({\n      char,\n      index\n    })).sort((a, b) => a.char.localeCompare(b.char));\n    for (let {\n      index\n    } of sortedKey) {\n      for (let row = 0; row < numRows; row++) {\n        if (grid[row][index] !== '') {\n          transposedText += grid[row][index];\n        }\n      }\n    }\n    return transposedText;\n  }\n  function decode(ciphertext, keyword, transpositionKey) {\n    let square = createPolybiusSquare(keyword);\n    let transpositionKeyLength = transpositionKey.length;\n    let numRows = Math.ceil(ciphertext.length / transpositionKeyLength);\n    let grid = Array.from({\n      length: numRows\n    }, () => new Array(transpositionKeyLength).fill(''));\n    let sortedKey = transpositionKey.split('').map((char, index) => ({\n      char,\n      index\n    })).sort((a, b) => a.char.localeCompare(b.char));\n    let charIndex = 0;\n    for (let {\n      index\n    } of sortedKey) {\n      for (let row = 0; row < numRows; row++) {\n        if (charIndex < ciphertext.length) {\n          grid[row][index] = ciphertext[charIndex++];\n        }\n      }\n    }\n    let coordinates = [];\n    for (let row of grid) {\n      for (let char of row) {\n        if (char !== '') {\n          coordinates.push(char);\n        }\n      }\n    }\n    let plaintext = \"\";\n    for (let i = 0; i < coordinates.length; i += 2) {\n      let row = polybiusSquare[0].indexOf(coordinates[i]);\n      let col = polybiusSquare[0].indexOf(coordinates[i + 1]);\n      plaintext += square[row][col];\n    }\n    return plaintext;\n  }\n  const showInformation = () => {\n    const info = /*#__PURE__*/_jsxDEV(_Fragment, {\n      children: [/*#__PURE__*/_jsxDEV(\"p\", {\n        children: \"The ADFGVX Cipher is a fractionated cipher used by the German Army during World War I. It is a combination of a modified Polybius square and a single columnar transposition.\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 124,\n        columnNumber: 13\n      }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n        children: \"To encrypt using the ADFGVX Cipher, you first substitute the plaintext using a Polybius square, then transpose the resulting fractionated ciphertext using a key.\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 128,\n        columnNumber: 13\n      }, this), /*#__PURE__*/_jsxDEV(\"ul\", {\n        children: [/*#__PURE__*/_jsxDEV(\"li\", {\n          children: \"Polybius Square: A 6x6 grid that includes the letters ADFGVX along the rows and columns. Each cell contains a letter of the alphabet or a digit.\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 133,\n          columnNumber: 17\n        }, this), /*#__PURE__*/_jsxDEV(\"li\", {\n          children: \"Substitution Step: Each letter of the plaintext is replaced by its coordinates in the Polybius square, resulting in a pair of ADFGVX letters.\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 134,\n          columnNumber: 17\n        }, this), /*#__PURE__*/_jsxDEV(\"li\", {\n          children: \"Transposition Step: The resulting pairs are written out in rows under the columns labeled with the key, and then the columns are rearranged according to the key.\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 135,\n          columnNumber: 17\n        }, this), /*#__PURE__*/_jsxDEV(\"li\", {\n          children: \"Encryption: Convert each plaintext character to a pair of ADFGVX letters, then reorder the pairs based on the transposition key.\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 136,\n          columnNumber: 17\n        }, this), /*#__PURE__*/_jsxDEV(\"li\", {\n          children: \"Decryption: Reverse the transposition to obtain the fractionated ciphertext, then use the Polybius square to get back the plaintext.\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 137,\n          columnNumber: 17\n        }, this), /*#__PURE__*/_jsxDEV(\"li\", {\n          children: \"Example: With the key 'KEYWORD' and plaintext 'HELLO', you might substitute 'H' as 'AF', 'E' as 'DG', etc., and then transpose the pairs based on the key.\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 138,\n          columnNumber: 17\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 132,\n        columnNumber: 13\n      }, this)]\n    }, void 0, true);\n    ongetInfo(info);\n  };\n  React.useEffect(() => {\n    showInformation();\n  }, []);\n  return /*#__PURE__*/_jsxDEV(CipherFactory, {\n    encode: encode,\n    decode: decode,\n    keyComponentA: 'STR',\n    keyComponentB: 'STR'\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 149,\n    columnNumber: 14\n  }, this);\n}\n_s(ADFGVX, \"OD7bBpZva5O2jO+Puf00hKivP7c=\");\n_c = ADFGVX;\n;\nvar _c;\n$RefreshReg$(_c, \"ADFGVX\");","map":{"version":3,"names":["React","CipherFactory","jsxDEV","_jsxDEV","Fragment","_Fragment","ADFGVX","ongetInfo","_s","polybiusSquare","createPolybiusSquare","keyword","alphabet","toUpperCase","replace","square","usedChars","Set","char","has","push","add","matrix","i","slice","getCoordinates","j","encode","plaintext","transpositionKey","coordinates","transposedText","transpositionKeyLength","length","numRows","Math","ceil","grid","Array","from","fill","floor","sortedKey","split","map","index","sort","a","b","localeCompare","row","decode","ciphertext","charIndex","indexOf","col","showInformation","info","children","fileName","_jsxFileName","lineNumber","columnNumber","useEffect","keyComponentA","keyComponentB","_c","$RefreshReg$"],"sources":["C:/Users/ankus/OneDrive/Desktop/Pro/ciphers/src/components/ciphers/ADFGVX.js"],"sourcesContent":["import React from 'react';\r\nimport CipherFactory from '../../ui/EncryptDecrypt';\r\n\r\n\r\nexport default function ADFGVX({ongetInfo}) {\r\n\r\n    const polybiusSquare = [\r\n        ['A', 'D', 'F', 'G', 'V', 'X'],\r\n        ['A', 'B', 'C', 'D', 'E', 'F'],\r\n        ['G', 'H', 'I', 'J', 'K', 'L'],\r\n        ['M', 'N', 'O', 'P', 'Q', 'R'],\r\n        ['S', 'T', 'U', 'V', 'W', 'X'],\r\n        ['Y', 'Z', '0', '1', '2', '3'],\r\n        ['4', '5', '6', '7', '8', '9']\r\n    ];\r\n    \r\n    function createPolybiusSquare(keyword) {\r\n        let alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";\r\n        keyword = keyword.toUpperCase().replace(/[^A-Z0-9]/g, '');\r\n        let square = [];\r\n        let usedChars = new Set();\r\n    \r\n        for (let char of keyword) {\r\n            if (!usedChars.has(char)) {\r\n                square.push(char);\r\n                usedChars.add(char);\r\n            }\r\n        }\r\n    \r\n        for (let char of alphabet) {\r\n            if (!usedChars.has(char)) {\r\n                square.push(char);\r\n                usedChars.add(char);\r\n            }\r\n        }\r\n    \r\n        let matrix = [];\r\n        for (let i = 0; i < 6; i++) {\r\n            matrix.push(square.slice(i * 6, i * 6 + 6));\r\n        }\r\n    \r\n        return matrix;\r\n    }\r\n    \r\n    function getCoordinates(char, square) {\r\n        for (let i = 0; i < 6; i++) {\r\n            for (let j = 0; j < 6; j++) {\r\n                if (square[i][j] === char) {\r\n                    return [polybiusSquare[0][i], polybiusSquare[0][j]];\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    \r\n    function encode(plaintext, keyword, transpositionKey) {\r\n        let square = createPolybiusSquare(keyword);\r\n        plaintext = plaintext.toUpperCase().replace(/[^A-Z0-9]/g, '');\r\n        let coordinates = [];\r\n    \r\n        for (let char of plaintext) {\r\n            coordinates.push(...getCoordinates(char, square));\r\n        }\r\n    \r\n        let transposedText = \"\";\r\n        let transpositionKeyLength = transpositionKey.length;\r\n        let numRows = Math.ceil(coordinates.length / transpositionKeyLength);\r\n        let grid = Array.from({ length: numRows }, () => new Array(transpositionKeyLength).fill(''));\r\n    \r\n        for (let i = 0; i < coordinates.length; i++) {\r\n            grid[Math.floor(i / transpositionKeyLength)][i % transpositionKeyLength] = coordinates[i];\r\n        }\r\n    \r\n        let sortedKey = transpositionKey.split('').map((char, index) => ({ char, index })).sort((a, b) => a.char.localeCompare(b.char));\r\n        for (let { index } of sortedKey) {\r\n            for (let row = 0; row < numRows; row++) {\r\n                if (grid[row][index] !== '') {\r\n                    transposedText += grid[row][index];\r\n                }\r\n            }\r\n        }\r\n    \r\n        return transposedText;\r\n    }\r\n    \r\n    function decode(ciphertext, keyword, transpositionKey) {\r\n        let square = createPolybiusSquare(keyword);\r\n        let transpositionKeyLength = transpositionKey.length;\r\n        let numRows = Math.ceil(ciphertext.length / transpositionKeyLength);\r\n        let grid = Array.from({ length: numRows }, () => new Array(transpositionKeyLength).fill(''));\r\n    \r\n        let sortedKey = transpositionKey.split('').map((char, index) => ({ char, index })).sort((a, b) => a.char.localeCompare(b.char));\r\n        let charIndex = 0;\r\n    \r\n        for (let { index } of sortedKey) {\r\n            for (let row = 0; row < numRows; row++) {\r\n                if (charIndex < ciphertext.length) {\r\n                    grid[row][index] = ciphertext[charIndex++];\r\n                }\r\n            }\r\n        }\r\n    \r\n        let coordinates = [];\r\n        for (let row of grid) {\r\n            for (let char of row) {\r\n                if (char !== '') {\r\n                    coordinates.push(char);\r\n                }\r\n            }\r\n        }\r\n    \r\n        let plaintext = \"\";\r\n        for (let i = 0; i < coordinates.length; i += 2) {\r\n            let row = polybiusSquare[0].indexOf(coordinates[i]);\r\n            let col = polybiusSquare[0].indexOf(coordinates[i + 1]);\r\n            plaintext += square[row][col];\r\n        }\r\n    \r\n        return plaintext;\r\n    }      \r\n  const showInformation = () => {\r\n    const info = (\r\n        <>\r\n            <p>\r\n                The ADFGVX Cipher is a fractionated cipher used by the German Army during World War I. \r\n                It is a combination of a modified Polybius square and a single columnar transposition.\r\n            </p>\r\n            <p>\r\n                To encrypt using the ADFGVX Cipher, you first substitute the plaintext using a Polybius square, \r\n                then transpose the resulting fractionated ciphertext using a key.\r\n            </p>\r\n            <ul>\r\n                <li>Polybius Square: A 6x6 grid that includes the letters ADFGVX along the rows and columns. Each cell contains a letter of the alphabet or a digit.</li>\r\n                <li>Substitution Step: Each letter of the plaintext is replaced by its coordinates in the Polybius square, resulting in a pair of ADFGVX letters.</li>\r\n                <li>Transposition Step: The resulting pairs are written out in rows under the columns labeled with the key, and then the columns are rearranged according to the key.</li>\r\n                <li>Encryption: Convert each plaintext character to a pair of ADFGVX letters, then reorder the pairs based on the transposition key.</li>\r\n                <li>Decryption: Reverse the transposition to obtain the fractionated ciphertext, then use the Polybius square to get back the plaintext.</li>\r\n                <li>Example: With the key 'KEYWORD' and plaintext 'HELLO', you might substitute 'H' as 'AF', 'E' as 'DG', etc., and then transpose the pairs based on the key.</li>\r\n            </ul>\r\n        </>\r\n    );\r\n    ongetInfo(info);\r\n};\r\n\r\nReact.useEffect(() => {\r\n    showInformation();\r\n}, []);\r\n\r\n      return <CipherFactory encode={encode} decode={decode} keyComponentA={'STR'} keyComponentB={'STR'} />\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}