{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\ankus\\\\OneDrive\\\\Desktop\\\\updated_ciphers\\\\ciphers_project\\\\src\\\\components\\\\ciphers\\\\Bifid.js\",\n  _s = $RefreshSig$();\nimport React from 'react';\nimport CipherFactory from '../../ui/EncryptDecrypt';\nimport { jsxDEV as _jsxDEV, Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nexport default function BifidCipher({\n  ongetInfo\n}) {\n  _s();\n  function generatePolybiusSquare(keyword) {\n    let alphabet = \"ABCDEFGHIKLMNOPQRSTUVWXYZ\";\n    keyword = keyword.toUpperCase().replace(/J/g, \"I\");\n    let square = [];\n    let usedLetters = new Set();\n    for (let char of keyword) {\n      if (!usedLetters.has(char)) {\n        square.push(char);\n        usedLetters.add(char);\n      }\n    }\n    for (let char of alphabet) {\n      if (!usedLetters.has(char)) {\n        square.push(char);\n        usedLetters.add(char);\n      }\n    }\n    return square;\n  }\n  function getCoordinates(char, square) {\n    let index = square.indexOf(char);\n    return [Math.floor(index / 5), index % 5];\n  }\n  function encode(plaintext, keyword) {\n    plaintext = plaintext.toUpperCase().replace(/J/g, \"I\").replace(/[^A-Z]/g, '');\n    let square = generatePolybiusSquare(keyword);\n    let coordinates = [];\n    for (let char of plaintext) {\n      coordinates.push(...getCoordinates(char, square));\n    }\n    let newCoordinates = [];\n    for (let i = 0; i < coordinates.length / 2; i++) {\n      newCoordinates.push([coordinates[i], coordinates[Math.floor(coordinates.length / 2) + i]]);\n    }\n    let ciphertext = \"\";\n    for (let [row, col] of newCoordinates) {\n      ciphertext += square[row * 5 + col];\n    }\n    return ciphertext;\n  }\n  function decode(ciphertext, keyword) {\n    ciphertext = ciphertext.toUpperCase().replace(/[^A-Z]/g, '');\n    let square = generatePolybiusSquare(keyword);\n    let coordinates = [];\n    for (let char of ciphertext) {\n      coordinates.push(...getCoordinates(char, square));\n    }\n    let rows = coordinates.slice(0, coordinates.length / 2);\n    let cols = coordinates.slice(coordinates.length / 2);\n    let plaintext = \"\";\n    for (let i = 0; i < rows.length; i++) {\n      plaintext += square[rows[i] * 5 + cols[i]];\n    }\n    return plaintext;\n  }\n  const showInformation = () => {\n    const info = /*#__PURE__*/_jsxDEV(_Fragment, {\n      children: [/*#__PURE__*/_jsxDEV(\"p\", {\n        children: \"The Bifid Cipher is a classical cipher that combines the Polybius square with transposition and fractionation. It was invented by Felix Delastelle and is known for its complexity and strength compared to other classical ciphers.\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 78,\n        columnNumber: 17\n      }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n        children: \"To encrypt using the Bifid Cipher, the plaintext is first converted into coordinates using a Polybius square. These coordinates are then split and rearranged before being mapped back to letters.\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 82,\n        columnNumber: 17\n      }, this), /*#__PURE__*/_jsxDEV(\"ul\", {\n        children: [/*#__PURE__*/_jsxDEV(\"li\", {\n          children: \"Polybius Square: A 5x5 grid filled with letters of the alphabet (I and J are often combined).\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 87,\n          columnNumber: 21\n        }, this), /*#__PURE__*/_jsxDEV(\"li\", {\n          children: \"Coordinates: Each letter in the plaintext is converted to its corresponding row and column numbers in the Polybius square.\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 88,\n          columnNumber: 21\n        }, this), /*#__PURE__*/_jsxDEV(\"li\", {\n          children: \"Transposition: The coordinates are then split into two separate groups (rows and columns) and rearranged.\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 89,\n          columnNumber: 21\n        }, this), /*#__PURE__*/_jsxDEV(\"li\", {\n          children: \"Encryption: The rearranged coordinates are converted back to letters using the Polybius square.\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 90,\n          columnNumber: 21\n        }, this), /*#__PURE__*/_jsxDEV(\"li\", {\n          children: \"Decryption: Decryption involves reversing the process by converting letters to coordinates, splitting and rearranging them, and then mapping back to letters.\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 91,\n          columnNumber: 21\n        }, this), /*#__PURE__*/_jsxDEV(\"li\", {\n          children: \"Example: With the plaintext 'HELLO', using the Polybius square, you might get coordinates, split and rearrange them, and then map them back to encrypted text.\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 92,\n          columnNumber: 21\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 86,\n        columnNumber: 17\n      }, this)]\n    }, void 0, true);\n    ongetInfo(info);\n  };\n  React.useEffect(() => {\n    showInformation();\n  }, []);\n  return /*#__PURE__*/_jsxDEV(CipherFactory, {\n    encode: encode,\n    decode: decode,\n    keyComponentA: 'STR'\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 103,\n    columnNumber: 12\n  }, this);\n}\n_s(BifidCipher, \"OD7bBpZva5O2jO+Puf00hKivP7c=\");\n_c = BifidCipher;\n;\nvar _c;\n$RefreshReg$(_c, \"BifidCipher\");","map":{"version":3,"names":["React","CipherFactory","jsxDEV","_jsxDEV","Fragment","_Fragment","BifidCipher","ongetInfo","_s","generatePolybiusSquare","keyword","alphabet","toUpperCase","replace","square","usedLetters","Set","char","has","push","add","getCoordinates","index","indexOf","Math","floor","encode","plaintext","coordinates","newCoordinates","i","length","ciphertext","row","col","decode","rows","slice","cols","showInformation","info","children","fileName","_jsxFileName","lineNumber","columnNumber","useEffect","keyComponentA","_c","$RefreshReg$"],"sources":["C:/Users/ankus/OneDrive/Desktop/updated_ciphers/ciphers_project/src/components/ciphers/Bifid.js"],"sourcesContent":["import React from 'react';\r\nimport CipherFactory from '../../ui/EncryptDecrypt';\r\n\r\nexport default function BifidCipher({ ongetInfo }) {\r\n    function generatePolybiusSquare(keyword) {\r\n        let alphabet = \"ABCDEFGHIKLMNOPQRSTUVWXYZ\";\r\n        keyword = keyword.toUpperCase().replace(/J/g, \"I\");\r\n        let square = [];\r\n        let usedLetters = new Set();\r\n    \r\n        for (let char of keyword) {\r\n            if (!usedLetters.has(char)) {\r\n                square.push(char);\r\n                usedLetters.add(char);\r\n            }\r\n        }\r\n    \r\n        for (let char of alphabet) {\r\n            if (!usedLetters.has(char)) {\r\n                square.push(char);\r\n                usedLetters.add(char);\r\n            }\r\n        }\r\n    \r\n        return square;\r\n    }\r\n    \r\n    function getCoordinates(char, square) {\r\n        let index = square.indexOf(char);\r\n        return [Math.floor(index / 5), index % 5];\r\n    }\r\n    \r\n    function encode(plaintext, keyword) {\r\n        plaintext = plaintext.toUpperCase().replace(/J/g, \"I\").replace(/[^A-Z]/g, '');\r\n        let square = generatePolybiusSquare(keyword);\r\n        let coordinates = [];\r\n    \r\n        for (let char of plaintext) {\r\n            coordinates.push(...getCoordinates(char, square));\r\n        }\r\n    \r\n        let newCoordinates = [];\r\n        for (let i = 0; i < coordinates.length / 2; i++) {\r\n            newCoordinates.push([coordinates[i], coordinates[Math.floor(coordinates.length / 2) + i]]);\r\n        }\r\n    \r\n        let ciphertext = \"\";\r\n        for (let [row, col] of newCoordinates) {\r\n            ciphertext += square[row * 5 + col];\r\n        }\r\n    \r\n        return ciphertext;\r\n    }\r\n    \r\n    function decode(ciphertext, keyword) {\r\n        ciphertext = ciphertext.toUpperCase().replace(/[^A-Z]/g, '');\r\n        let square = generatePolybiusSquare(keyword);\r\n        let coordinates = [];\r\n    \r\n        for (let char of ciphertext) {\r\n            coordinates.push(...getCoordinates(char, square));\r\n        }\r\n    \r\n        let rows = coordinates.slice(0, coordinates.length / 2);\r\n        let cols = coordinates.slice(coordinates.length / 2);\r\n    \r\n        let plaintext = \"\";\r\n        for (let i = 0; i < rows.length; i++) {\r\n            plaintext += square[rows[i] * 5 + cols[i]];\r\n        }\r\n    \r\n        return plaintext;\r\n    }\r\n        \r\n    const showInformation = () => {\r\n        const info = (\r\n            <>\r\n                <p>\r\n                    The Bifid Cipher is a classical cipher that combines the Polybius square with transposition and fractionation. \r\n                    It was invented by Felix Delastelle and is known for its complexity and strength compared to other classical ciphers.\r\n                </p>\r\n                <p>\r\n                    To encrypt using the Bifid Cipher, the plaintext is first converted into coordinates using a Polybius square. \r\n                    These coordinates are then split and rearranged before being mapped back to letters.\r\n                </p>\r\n                <ul>\r\n                    <li>Polybius Square: A 5x5 grid filled with letters of the alphabet (I and J are often combined).</li>\r\n                    <li>Coordinates: Each letter in the plaintext is converted to its corresponding row and column numbers in the Polybius square.</li>\r\n                    <li>Transposition: The coordinates are then split into two separate groups (rows and columns) and rearranged.</li>\r\n                    <li>Encryption: The rearranged coordinates are converted back to letters using the Polybius square.</li>\r\n                    <li>Decryption: Decryption involves reversing the process by converting letters to coordinates, splitting and rearranging them, and then mapping back to letters.</li>\r\n                    <li>Example: With the plaintext 'HELLO', using the Polybius square, you might get coordinates, split and rearrange them, and then map them back to encrypted text.</li>\r\n                </ul>\r\n            </>\r\n        );\r\n        ongetInfo(info);\r\n    };\r\n\r\n    React.useEffect(() => {\r\n        showInformation();\r\n    }, []);\r\n\r\n    return <CipherFactory encode={encode} decode={decode} keyComponentA={'STR'}/>\r\n};\r\n\r\n\r\n\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}