{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\ankus\\\\OneDrive\\\\Desktop\\\\Pro\\\\ciphers\\\\src\\\\components\\\\ciphers\\\\AMSCO.js\",\n  _s = $RefreshSig$();\nimport React from 'react';\nimport CipherFactory from '../../ui/EncryptDecrypt';\nimport { jsxDEV as _jsxDEV, Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nexport default function CipherAscii({\n  ongetInfo\n}) {\n  _s();\n  // Function to generate the transposition grid based on the keyword\n  // Function to generate the transposition grid based on the keyword\n\n  // Function to encrypt the plaintext using the AMSCO cipher\n  function encode(text, keyword) {\n    // Prepare keyword and derive the order\n    if (!keyword) {\n      console.error(\"Keyword is empty or not provided.\");\n      return;\n    }\n    const keyArray = keyword.split('').map((char, i) => ({\n      char,\n      index: i\n    }));\n    keyArray.sort((a, b) => a.char.localeCompare(b.char));\n    const keyOrder = keyArray.map(item => item.index);\n\n    // Initialize variables\n    const numCols = keyword.length;\n    const numRows = Math.ceil(text.length / Math.ceil(keyword.length / 1.5));\n    const grid = Array.from({\n      length: numRows\n    }, () => Array(numCols).fill(''));\n    let textIndex = 0;\n    let charCount = 1; // Start with 1 character per cell\n\n    // Fill the grid with text\n    for (let row = 0; row < numRows; row++) {\n      for (let col = 0; col < numCols; col++) {\n        if (textIndex < text.length) {\n          grid[row][col] = text.substr(textIndex, charCount);\n          textIndex += charCount;\n          charCount = charCount === 1 ? 2 : 1; // Alternate between 1 and 2 characters\n        }\n      }\n    }\n\n    // Read the grid column-wise according to the key order\n    let encryptedText = '';\n    for (let col of keyOrder) {\n      for (let row = 0; row < numRows; row++) {\n        encryptedText += grid[row][col];\n      }\n    }\n    return encryptedText;\n  }\n\n  // Function to decrypt the ciphertext using the AMSCO cipher\n  function decode(encryptedText, keyword) {\n    const keyArray = keyword.split('').map((char, i) => ({\n      char,\n      index: i\n    }));\n    keyArray.sort((a, b) => a.char.localeCompare(b.char));\n    const keyOrder = keyArray.map(item => item.index);\n\n    // Initialize variables\n    const numCols = keyword.length;\n    const numRows = Math.ceil(encryptedText.length / Math.ceil(keyword.length / 1.5));\n    const grid = Array.from({\n      length: numRows\n    }, () => Array(numCols).fill(''));\n    let charCount = 1; // Start with 1 character per cell\n\n    // Calculate the length of each column\n    const colLengths = Array(numCols).fill(0);\n    let textIndex = 0;\n    for (let row = 0; row < numRows; row++) {\n      for (let col = 0; col < numCols; col++) {\n        if (textIndex < encryptedText.length) {\n          colLengths[col]++;\n          textIndex += charCount;\n          charCount = charCount === 1 ? 2 : 1; // Alternate between 1 and 2 characters\n        }\n      }\n    }\n\n    // Fill the grid column-wise according to the key order\n    textIndex = 0;\n    for (let i = 0; i < keyOrder.length; i++) {\n      let col = keyOrder[i];\n      for (let row = 0; row < numRows; row++) {\n        if (colLengths[col] > 0 && textIndex < encryptedText.length) {\n          let length = charCount;\n          grid[row][col] = encryptedText.substr(textIndex, length);\n          textIndex += length;\n          colLengths[col]--;\n          charCount = charCount === 1 ? 2 : 1; // Alternate between 1 and 2 characters\n        }\n      }\n    }\n\n    // Read the grid row-wise to get the original text\n    let decryptedText = '';\n    charCount = 1; // Start with 1 character per cell again\n    for (let row = 0; row < numRows; row++) {\n      for (let col = 0; col < numCols; col++) {\n        if (grid[row][col]) {\n          decryptedText += grid[row][col];\n        }\n      }\n    }\n    return decryptedText;\n  }\n  const showInformation = () => {\n    const info = /*#__PURE__*/_jsxDEV(_Fragment, {\n      children: [/*#__PURE__*/_jsxDEV(\"p\", {\n        children: \"The ASCII Cipher is a simple character substitution cipher based on the ASCII encoding standard. Each character in the plaintext is replaced with its corresponding ASCII value.\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 107,\n        columnNumber: 17\n      }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n        children: \"To encrypt using the ASCII Cipher, simply convert each character of your text to its ASCII value.\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 111,\n        columnNumber: 17\n      }, this), /*#__PURE__*/_jsxDEV(\"ul\", {\n        children: [/*#__PURE__*/_jsxDEV(\"li\", {\n          children: \"Substitution Cipher: Each character in the plaintext is replaced by its corresponding ASCII value.\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 115,\n          columnNumber: 21\n        }, this), /*#__PURE__*/_jsxDEV(\"li\", {\n          children: \"ASCII Encoding: ASCII (American Standard Code for Information Interchange) is a character encoding standard that represents text in computers and other devices.\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 116,\n          columnNumber: 21\n        }, this), /*#__PURE__*/_jsxDEV(\"li\", {\n          children: \"Encryption: To encrypt, convert each character in the plaintext to its ASCII value.\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 117,\n          columnNumber: 21\n        }, this), /*#__PURE__*/_jsxDEV(\"li\", {\n          children: \"Decryption: Decryption involves converting each ASCII value back to its corresponding character.\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 118,\n          columnNumber: 21\n        }, this), /*#__PURE__*/_jsxDEV(\"li\", {\n          children: \"Example: 'A' becomes '65', 'B' becomes '66', 'C' becomes '67', and so forth.\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 119,\n          columnNumber: 21\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 114,\n        columnNumber: 17\n      }, this)]\n    }, void 0, true);\n    ongetInfo(info);\n  };\n  React.useEffect(() => {\n    showInformation();\n  }, []);\n  return /*#__PURE__*/_jsxDEV(CipherFactory, {\n    encode: encode,\n    decode: decode,\n    keyComponentA: 'STR'\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 130,\n    columnNumber: 12\n  }, this);\n}\n_s(CipherAscii, \"OD7bBpZva5O2jO+Puf00hKivP7c=\");\n_c = CipherAscii;\n;\nvar _c;\n$RefreshReg$(_c, \"CipherAscii\");","map":{"version":3,"names":["React","CipherFactory","jsxDEV","_jsxDEV","Fragment","_Fragment","CipherAscii","ongetInfo","_s","encode","text","keyword","console","error","keyArray","split","map","char","i","index","sort","a","b","localeCompare","keyOrder","item","numCols","length","numRows","Math","ceil","grid","Array","from","fill","textIndex","charCount","row","col","substr","encryptedText","decode","colLengths","decryptedText","showInformation","info","children","fileName","_jsxFileName","lineNumber","columnNumber","useEffect","keyComponentA","_c","$RefreshReg$"],"sources":["C:/Users/ankus/OneDrive/Desktop/Pro/ciphers/src/components/ciphers/AMSCO.js"],"sourcesContent":["import React from 'react';\r\nimport CipherFactory from '../../ui/EncryptDecrypt';\r\n\r\nexport default function CipherAscii({ ongetInfo }) {\r\n    // Function to generate the transposition grid based on the keyword\r\n    // Function to generate the transposition grid based on the keyword\r\n\r\n\r\n    // Function to encrypt the plaintext using the AMSCO cipher\r\n    function encode(text, keyword) {\r\n        // Prepare keyword and derive the order\r\n        if (!keyword) {\r\n            console.error(\"Keyword is empty or not provided.\");\r\n            return;\r\n          }\r\n          \r\n          const keyArray = keyword.split('').map((char, i) => ({char, index: i}));\r\n          keyArray.sort((a, b) => a.char.localeCompare(b.char));\r\n          const keyOrder = keyArray.map(item => item.index);\r\n          \r\n  // Initialize variables\r\n  const numCols = keyword.length;\r\n  const numRows = Math.ceil(text.length / Math.ceil(keyword.length / 1.5));\r\n  const grid = Array.from({ length: numRows }, () => Array(numCols).fill(''));\r\n  let textIndex = 0;\r\n  let charCount = 1; // Start with 1 character per cell\r\n\r\n  // Fill the grid with text\r\n  for (let row = 0; row < numRows; row++) {\r\n    for (let col = 0; col < numCols; col++) {\r\n      if (textIndex < text.length) {\r\n        grid[row][col] = text.substr(textIndex, charCount);\r\n        textIndex += charCount;\r\n        charCount = charCount === 1 ? 2 : 1; // Alternate between 1 and 2 characters\r\n      }\r\n    }\r\n  }\r\n\r\n  // Read the grid column-wise according to the key order\r\n  let encryptedText = '';\r\n  for (let col of keyOrder) {\r\n    for (let row = 0; row < numRows; row++) {\r\n      encryptedText += grid[row][col];\r\n    }\r\n  }\r\n\r\n  return encryptedText;\r\n    }\r\n\r\n    // Function to decrypt the ciphertext using the AMSCO cipher\r\n    function decode(encryptedText, keyword) {\r\n        const keyArray = keyword.split('').map((char, i) => ({char, index: i}));\r\n  keyArray.sort((a, b) => a.char.localeCompare(b.char));\r\n  const keyOrder = keyArray.map(item => item.index);\r\n\r\n  // Initialize variables\r\n  const numCols = keyword.length;\r\n  const numRows = Math.ceil(encryptedText.length / Math.ceil(keyword.length / 1.5));\r\n  const grid = Array.from({ length: numRows }, () => Array(numCols).fill(''));\r\n  let charCount = 1; // Start with 1 character per cell\r\n\r\n  // Calculate the length of each column\r\n  const colLengths = Array(numCols).fill(0);\r\n  let textIndex = 0;\r\n  for (let row = 0; row < numRows; row++) {\r\n    for (let col = 0; col < numCols; col++) {\r\n      if (textIndex < encryptedText.length) {\r\n        colLengths[col]++;\r\n        textIndex += charCount;\r\n        charCount = charCount === 1 ? 2 : 1; // Alternate between 1 and 2 characters\r\n      }\r\n    }\r\n  }\r\n\r\n  // Fill the grid column-wise according to the key order\r\n  textIndex = 0;\r\n  for (let i = 0; i < keyOrder.length; i++) {\r\n    let col = keyOrder[i];\r\n    for (let row = 0; row < numRows; row++) {\r\n      if (colLengths[col] > 0 && textIndex < encryptedText.length) {\r\n        let length = charCount;\r\n        grid[row][col] = encryptedText.substr(textIndex, length);\r\n        textIndex += length;\r\n        colLengths[col]--;\r\n        charCount = charCount === 1 ? 2 : 1; // Alternate between 1 and 2 characters\r\n      }\r\n    }\r\n  }\r\n\r\n  // Read the grid row-wise to get the original text\r\n  let decryptedText = '';\r\n  charCount = 1; // Start with 1 character per cell again\r\n  for (let row = 0; row < numRows; row++) {\r\n    for (let col = 0; col < numCols; col++) {\r\n      if (grid[row][col]) {\r\n        decryptedText += grid[row][col];\r\n      }\r\n    }\r\n  }\r\n\r\n  return decryptedText;\r\n    }\r\n\r\n    const showInformation = () => {\r\n        const info = (\r\n            <>\r\n                <p>\r\n                    The ASCII Cipher is a simple character substitution cipher based on the ASCII encoding standard. \r\n                    Each character in the plaintext is replaced with its corresponding ASCII value.\r\n                </p>\r\n                <p>\r\n                    To encrypt using the ASCII Cipher, simply convert each character of your text to its ASCII value.\r\n                </p>\r\n                <ul>\r\n                    <li>Substitution Cipher: Each character in the plaintext is replaced by its corresponding ASCII value.</li>\r\n                    <li>ASCII Encoding: ASCII (American Standard Code for Information Interchange) is a character encoding standard that represents text in computers and other devices.</li>\r\n                    <li>Encryption: To encrypt, convert each character in the plaintext to its ASCII value.</li>\r\n                    <li>Decryption: Decryption involves converting each ASCII value back to its corresponding character.</li>\r\n                    <li>Example: 'A' becomes '65', 'B' becomes '66', 'C' becomes '67', and so forth.</li>\r\n                </ul>\r\n            </>\r\n        );\r\n        ongetInfo(info);\r\n    };\r\n\r\n    React.useEffect(() => {\r\n        showInformation();\r\n    }, []);\r\n\r\n    return <CipherFactory encode={encode} decode={decode} keyComponentA={'STR'} />\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}