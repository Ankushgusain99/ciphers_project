{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\ankus\\\\OneDrive\\\\Desktop\\\\Pro\\\\ciphers\\\\src\\\\components\\\\ciphers\\\\ADFGVX.js\",\n  _s = $RefreshSig$();\nimport React from 'react';\nimport CipherFactory from '../../ui/EncryptDecrypt';\nimport { jsxDEV as _jsxDEV, Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nexport default function ADFGVC({\n  ongetInfo\n}) {\n  _s();\n  const adfgvx = 'ADFGVX';\n  let polybiusSquare = createPolybiusSquare('phqgiumeaylnofdxkrcvstzwb');\n  function createPolybiusSquare(alphabet) {\n    const size = 6;\n    let square = [];\n    for (let i = 0; i < size; i++) {\n      square[i] = [];\n      for (let j = 0; j < size; j++) {\n        square[i][j] = alphabet[i * size + j];\n      }\n    }\n    return square;\n  }\n  function indexOf2d(arr, val) {\n    for (let i = 0; i < arr.length; i++) {\n      let index = arr[i].indexOf(val);\n      if (index > -1) {\n        return [i, index];\n      }\n    }\n    return [-1, -1];\n  }\n  function encode(plaintext, key) {\n    console.log(plaintext, key);\n    plaintext = plaintext.toLowerCase().replace(/[^a-z]/g, '');\n    let cipher = '';\n\n    // Substitute with Polybius Square\n    for (let char of plaintext) {\n      let [row, col] = indexOf2d(polybiusSquare, char);\n      cipher += adfgvx[row] + adfgvx[col];\n    }\n\n    // Columnar Transposition\n    return transpositionCipher(cipher, key);\n  }\n  function decode(ciphertext, key) {\n    let decrypted = reverseTranspositionCipher(ciphertext, key);\n    let plaintext = '';\n\n    // Reverse Polybius Square substitution\n    for (let i = 0; i < decrypted.length; i += 2) {\n      let row = adfgvx.indexOf(decrypted[i]);\n      let col = adfgvx.indexOf(decrypted[i + 1]);\n      plaintext += polybiusSquare[row][col];\n    }\n    return plaintext;\n  }\n  function transpositionCipher(text, key) {\n    if (!text || !key || text.length === 0 || key.length === 0) {\n      throw new Error('Invalid input: text and key must be provided');\n    }\n    // Create an array to represent key-index mapping\n    let keyMap = [];\n    for (let i = 0; i < key.length; i++) {\n      keyMap.push({\n        char: key[i],\n        index: i\n      });\n    }\n\n    // Sort the key map based on alphabetical order of key\n    keyMap.sort((a, b) => a.char.localeCompare(b.char));\n\n    // Create the matrix to cipher the text\n    let rowLength = key.length;\n    let textLength = text.length;\n    let numRows = Math.ceil(textLength / rowLength);\n    let matrix = [];\n    for (let i = 0; i < numRows; i++) {\n      let row = text.slice(i * rowLength, (i + 1) * rowLength).padEnd(rowLength, ' ');\n      matrix.push(row.split(''));\n    }\n\n    // Transpose the matrix based on the key map\n    let cipherText = '';\n    for (let {\n      index\n    } of keyMap) {\n      for (let row of matrix) {\n        cipherText += row[index];\n      }\n    }\n    return cipherText.replace(/ /g, ''); // Remove padding spaces\n  }\n  function reverseTranspositionCipher(text, key) {\n    if (!text || !key || text.length === 0 || key.length === 0) {\n      throw new Error('Invalid input: text and key must be provided');\n    }\n    // Reverse the process of the transpositionCipher function\n    let keyMap = [];\n    for (let i = 0; i < key.length; i++) {\n      keyMap.push({\n        char: key[i],\n        index: i\n      });\n    }\n    keyMap.sort((a, b) => a.char.localeCompare(b.char));\n    let colLength = Math.ceil(text.length / key.length);\n    let numRows = key.length;\n    let totalCells = colLength * numRows;\n    let padding = totalCells - text.length;\n    let matrix = [];\n    for (let i = 0; i < numRows; i++) {\n      matrix.push(new Array(colLength).fill(' '));\n    }\n    let index = 0;\n    for (let {\n      index: keyIndex\n    } of keyMap) {\n      for (let i = 0; i < colLength; i++) {\n        if (padding > 0 && i === colLength - 1 && keyIndex >= numRows - padding) {\n          continue;\n        }\n        matrix[keyIndex][i] = text[index];\n        index++;\n      }\n    }\n\n    // Read the matrix row-wise to get the original text\n    let originalText = '';\n    for (let i = 0; i < colLength; i++) {\n      for (let j = 0; j < numRows; j++) {\n        originalText += matrix[j][i];\n      }\n    }\n    return originalText.replace(/ /g, ''); // Remove padding spaces\n  }\n  const showInformation = () => {\n    const info = /*#__PURE__*/_jsxDEV(_Fragment, {\n      children: [/*#__PURE__*/_jsxDEV(\"p\", {\n        children: \"The ADFGVX cipher is a field cipher used by the German Army during World War I.\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 143,\n        columnNumber: 17\n      }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n        children: \"To encrypt using the ADFGVX cipher, a Polybius square and a transposition cipher are combined.\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 146,\n        columnNumber: 17\n      }, this), /*#__PURE__*/_jsxDEV(\"ul\", {\n        children: [/*#__PURE__*/_jsxDEV(\"li\", {\n          children: \"Substitution Cipher: The plaintext is first converted into pairs of ADFGVX characters based on their positions in a Polybius square.\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 150,\n          columnNumber: 21\n        }, this), /*#__PURE__*/_jsxDEV(\"li\", {\n          children: \"Transposition: The resulting pairs are then reordered according to a keyword.\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 151,\n          columnNumber: 21\n        }, this), /*#__PURE__*/_jsxDEV(\"li\", {\n          children: \"Encryption: The final result is the encrypted ciphertext.\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 152,\n          columnNumber: 21\n        }, this), /*#__PURE__*/_jsxDEV(\"li\", {\n          children: \"Decryption: The ciphertext is reordered according to the keyword to retrieve the pairs of ADFGVX characters, which are then converted back into plaintext.\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 153,\n          columnNumber: 21\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 149,\n        columnNumber: 17\n      }, this)]\n    }, void 0, true);\n    ongetInfo(info);\n  };\n  React.useEffect(() => {\n    showInformation();\n  }, []);\n  return /*#__PURE__*/_jsxDEV(_Fragment, {\n    children: /*#__PURE__*/_jsxDEV(CipherFactory, {\n      encode: encode,\n      decode: decode,\n      keyComponentA: \"abc\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 166,\n      columnNumber: 13\n    }, this)\n  }, void 0, false);\n}\n_s(ADFGVC, \"OD7bBpZva5O2jO+Puf00hKivP7c=\");\n_c = ADFGVC;\n;\nvar _c;\n$RefreshReg$(_c, \"ADFGVC\");","map":{"version":3,"names":["React","CipherFactory","jsxDEV","_jsxDEV","Fragment","_Fragment","ADFGVC","ongetInfo","_s","adfgvx","polybiusSquare","createPolybiusSquare","alphabet","size","square","i","j","indexOf2d","arr","val","length","index","indexOf","encode","plaintext","key","console","log","toLowerCase","replace","cipher","char","row","col","transpositionCipher","decode","ciphertext","decrypted","reverseTranspositionCipher","text","Error","keyMap","push","sort","a","b","localeCompare","rowLength","textLength","numRows","Math","ceil","matrix","slice","padEnd","split","cipherText","colLength","totalCells","padding","Array","fill","keyIndex","originalText","showInformation","info","children","fileName","_jsxFileName","lineNumber","columnNumber","useEffect","keyComponentA","_c","$RefreshReg$"],"sources":["C:/Users/ankus/OneDrive/Desktop/Pro/ciphers/src/components/ciphers/ADFGVX.js"],"sourcesContent":["import React from 'react';\r\nimport CipherFactory from '../../ui/EncryptDecrypt';\r\n\r\nexport default function ADFGVC({ ongetInfo }) {\r\n\r\n    const adfgvx = 'ADFGVX';\r\nlet polybiusSquare = createPolybiusSquare('phqgiumeaylnofdxkrcvstzwb');\r\n\r\nfunction createPolybiusSquare(alphabet) {\r\n  const size = 6;\r\n  let square = [];\r\n  for (let i = 0; i < size; i++) {\r\n    square[i] = [];\r\n    for (let j = 0; j < size; j++) {\r\n      square[i][j] = alphabet[i * size + j];\r\n    }\r\n  }\r\n  return square;\r\n}\r\n\r\nfunction indexOf2d(arr, val) {\r\n  for (let i = 0; i < arr.length; i++) {\r\n    let index = arr[i].indexOf(val);\r\n    if (index > -1) {\r\n      return [i, index];\r\n    }\r\n  }\r\n  return [-1, -1];\r\n}\r\n\r\nfunction encode(plaintext, key) {\r\n    console.log(plaintext,key)\r\n  plaintext = plaintext.toLowerCase().replace(/[^a-z]/g, '');\r\n  let cipher = '';\r\n\r\n  // Substitute with Polybius Square\r\n  for (let char of plaintext) {\r\n    let [row, col] = indexOf2d(polybiusSquare, char);\r\n    cipher += adfgvx[row] + adfgvx[col];\r\n  }\r\n\r\n  // Columnar Transposition\r\n  return transpositionCipher(cipher, key);\r\n}\r\n\r\nfunction decode(ciphertext, key) {\r\n  let decrypted = reverseTranspositionCipher(ciphertext, key);\r\n  let plaintext = '';\r\n\r\n  // Reverse Polybius Square substitution\r\n  for (let i = 0; i < decrypted.length; i += 2) {\r\n    let row = adfgvx.indexOf(decrypted[i]);\r\n    let col = adfgvx.indexOf(decrypted[i + 1]);\r\n    plaintext += polybiusSquare[row][col];\r\n  }\r\n\r\n  return plaintext;\r\n}\r\n\r\nfunction transpositionCipher(text, key) {\r\n    if (!text || !key || text.length === 0 || key.length === 0) {\r\n        throw new Error('Invalid input: text and key must be provided');\r\n      }\r\n  // Create an array to represent key-index mapping\r\n  let keyMap = [];\r\n  for (let i = 0; i < key.length; i++) {\r\n    keyMap.push({ char: key[i], index: i });\r\n  }\r\n\r\n  // Sort the key map based on alphabetical order of key\r\n  keyMap.sort((a, b) => a.char.localeCompare(b.char));\r\n\r\n  // Create the matrix to cipher the text\r\n  let rowLength = key.length;\r\n  let textLength = text.length;\r\n  let numRows = Math.ceil(textLength / rowLength);\r\n  let matrix = [];\r\n\r\n  for (let i = 0; i < numRows; i++) {\r\n    let row = text.slice(i * rowLength, (i + 1) * rowLength).padEnd(rowLength, ' ');\r\n    matrix.push(row.split(''));\r\n  }\r\n\r\n  // Transpose the matrix based on the key map\r\n  let cipherText = '';\r\n  for (let { index } of keyMap) {\r\n    for (let row of matrix) {\r\n      cipherText += row[index];\r\n    }\r\n  }\r\n\r\n  return cipherText.replace(/ /g, ''); // Remove padding spaces\r\n}\r\n\r\nfunction reverseTranspositionCipher(text, key) {\r\n    if (!text || !key || text.length === 0 || key.length === 0) {\r\n        throw new Error('Invalid input: text and key must be provided');\r\n      }\r\n  // Reverse the process of the transpositionCipher function\r\n  let keyMap = [];\r\n  for (let i = 0; i < key.length; i++) {\r\n    keyMap.push({ char: key[i], index: i });\r\n  }\r\n\r\n  keyMap.sort((a, b) => a.char.localeCompare(b.char));\r\n\r\n  let colLength = Math.ceil(text.length / key.length);\r\n  let numRows = key.length;\r\n  let totalCells = colLength * numRows;\r\n  let padding = totalCells - text.length;\r\n  let matrix = [];\r\n\r\n  for (let i = 0; i < numRows; i++) {\r\n    matrix.push(new Array(colLength).fill(' '));\r\n  }\r\n\r\n  let index = 0;\r\n  for (let { index: keyIndex } of keyMap) {\r\n    for (let i = 0; i < colLength; i++) {\r\n      if (padding > 0 && i === colLength - 1 && keyIndex >= numRows - padding) {\r\n        continue;\r\n      }\r\n      matrix[keyIndex][i] = text[index];\r\n      index++;\r\n    }\r\n  }\r\n\r\n  // Read the matrix row-wise to get the original text\r\n  let originalText = '';\r\n  for (let i = 0; i < colLength; i++) {\r\n    for (let j = 0; j < numRows; j++) {\r\n      originalText += matrix[j][i];\r\n    }\r\n  }\r\n\r\n  return originalText.replace(/ /g, ''); // Remove padding spaces\r\n}\r\n\r\n\r\n    const showInformation = () => {\r\n        const info = (\r\n            <>\r\n                <p>\r\n                    The ADFGVX cipher is a field cipher used by the German Army during World War I.\r\n                </p>\r\n                <p>\r\n                    To encrypt using the ADFGVX cipher, a Polybius square and a transposition cipher are combined.\r\n                </p>\r\n                <ul>\r\n                    <li>Substitution Cipher: The plaintext is first converted into pairs of ADFGVX characters based on their positions in a Polybius square.</li>\r\n                    <li>Transposition: The resulting pairs are then reordered according to a keyword.</li>\r\n                    <li>Encryption: The final result is the encrypted ciphertext.</li>\r\n                    <li>Decryption: The ciphertext is reordered according to the keyword to retrieve the pairs of ADFGVX characters, which are then converted back into plaintext.</li>\r\n                </ul>\r\n            </>\r\n        );\r\n        ongetInfo(info);\r\n    };\r\n\r\n    React.useEffect(() => {\r\n        showInformation();\r\n    }, []);\r\n\r\n    return (\r\n        <>\r\n            <CipherFactory encode={encode} decode={decode} keyComponentA={\"abc\"} />\r\n        </>\r\n    );\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}